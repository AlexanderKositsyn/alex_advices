# alex_advices

## img

* заружать изображения размером с контейнер   

![фото](img/img1.png "фото")    

* для поддержки и чтобы картинка не искажалась в  ie картинки вставлять bg и потом в этот же элемент вставлять img, но img мы скрываем.



## ссылка   

* если логотип, то прописывать href='/' (ведет в корень и ищет там файл с index) 

## layout  

![фото](img/img2.png "фото")    
* html растягивается под viewport, а скролл появляется из за body а не html

## Верстка
  * Все текста оборачивать в span

## Работа с дизайнером  

* требовать шрифты

## Шрифты

* не зыбыть подключить символы кириллицы
* подключать запасные шрифты
* таблица font-weight   
![фото](img/img3.png "фото")
* подключать сглаживание шрифтов    
  -webkit-font-smoothing: antialiased;   
  -moz-osx-font-smoothing: grayscale;   

## Лендинг
* ставить min-height по макету(для каждого макета по ширинам laptop mobile tablet и т д ), чтобы если уменьштся viewport то секция сжиматься не будет при viewport меньше 650px    
* для того чтобы background не урезался во время уменьшения viewport можно для каждого разрешения вырезать свой отдельный background    


## SVG   
* Как отображается svg в браузере.
  1. создается холст размером с viewbox 
  2. на нем рисуется элемент (типо path circle и т.д.)
  3. весь viewbox растягивается по svg элементу (viewport)   
 
 ## Формы
* убираем реальную кнопку только через left:-9999px , потому что может появиться скрол по потоку если ставить обратное значение

## Pixel Perfect   
* для адаптивной верстки и вообще когда элемент плавает по старнице в зависимости от viewport, то подгоняем под PP только не плавающие элементы страницы.    
* если сайт резиновый то 1) подгоняем ширину viewport под макет(который в psd) 2) и под такой размер ставим проценты для измерений.

## Fiewfox    
* для flexitems ставить margin в px или в vh    

## IE11 IE10
* задавать явно св во flex для flexitems

## DOM
* функция requestAnimationFrame принимает в качестве параметра callback, который выполнится, когда браузер будет перерисовывать следующий кадр браузерной страницы(отрисовка страницы примерно проивходит 60 раз в секунду в зависимости от мощности компа)
## js
* Алгоритм выполнения кода.     
1=> Сверху-вниз     
2=> Cправа на лево(по операционно a || b || c , сначала b||c)     
3=> Cлева на право(в самой операции, допустим a || b, первая a потом b)    
* самое основное правило в JS. Все объекты в js записываются в виде ссылки в память и передаются в виде ссылки на память. Даже когда присваивается в первый раз в переменную.
* правило четырех П 
  1. Подготовка
  2. Планировка
  3. Процесс написания кода
  4. Приведение к перфект  
* новый стандарт ES6+
  - писать код всегда в новом стандарте;  
  - использовать транскомпилятор для старых браузеров (babel)(es6fiddle);
  - использовать shim для релаизации новых возможностей в старых браузерах;
* правило написания кода
  - Создать все необходимые перменные
  - Проверить наличие элемента или не пустая ли перемнная над которой производим действие
* правило для callback функций и обработчиков
  - Eсли функцию завести в переменную, то он ее не будет заново создавать. А если в обработчике будет стоять анонимная, то браузер будет каждый раз ее создавать, а не брать из переменной.
* прототипы в JS. В __proto__ записывается прототип объекта. prototype св-во у объекта, с помошью которого записывается св-во __proto__  у нового обхекта через оператор new. У фукнции в protortype записан конструктор, для того чтобы новый созданный при помощи этого конструктора знал от какого конструктора он был создан, т е prototype нужен для того чтобы в новый объект записался нужный прототип.   
* FriendFilter.prototype - это св-во __функции__ (конструктора, не нового истанса), у инстанса его нет(если заглянуть в конструктор то будет, да).
* .prototype указывает на прототип который будет записан при создании нового объекта через new.   
![фото](img/img5.png "фото")   
* при вызове new
 1) Создается пустой объект уже  со св-вом __proto__ в котором есть constructor который его создал и __proto__ для Конструктора(возможно это Object)
 2) this - это новый объект в функции конструкторе
 3) В конце не явно возращается this, или явно - что-то другое, что укажет программист.

## Как понять рекусию?
 **( то что описано ниже нужно представить в реальном мире как будто ты босс и зовешь других людей, которые зовут в свою очередь других людей, а ты  знаешь только о существовании того, которого позвал ты как босс)**
 1) Передо мной есть допустим 4 ящика.
 2) Для того чтобы рекурсивно получить все содержимое ящиков необходимо что бы Я "позвал человека и рассказать ему Действия и передать Суммарную сумку(это может быть массив, переменная и т.п.), которые он должен выполнить"(т.е. в коде это первый вызов функции). Действия которые Я ему сообщаю следующие:   
    a) если у него ящик последний, то он НЕ зовет следующего человека и не сообщает ему Действия и Суммарную сумку.   
    б) если еще есть ящики, то позвать человека и рассказать ему Действия и передать Суммарную сумку.(аналогично что и вызвать функцию)  
    в) если ты последний, то открыть ящик и положить в Суммарный сумку и передать её тому человеку который тебя вызвал.   
    г) если тебе передал человек, которого ты вызвал, суммарную сумку, то открой свой ящик и забери от туда все и положи в Суммарную сумку и передай его человеку, который тебя вызвал.  
   д) если ты не последний, то передать Суммарный сумку.
## Promise
 * код внутри конструктора Promise вызвается сразу во время основного потока кода
 * функции внутри then выполняются после вызова resolve и после основного потока как и setTimeOut
 * then возвращает promise
 * если в then вызвращается promise, то следующий then ждет пока разрешится promise который вернулся
 * когда в коде встречается .then, то к promise добавляется обработчик в его очередь
 * очередь из then выполнятеся только после того как интерпретатору нечего делать. примерно тоже самое что и setTimeOut
  
## try..catch
 * Самая важная функция try..catch в том что скрипт не падает, и мы получаем возможность обработать ошибку внутри catch

## hover
* если при ховере выскакивает подсказка, и на нее человек дожен перейти, то необходимо эту подсказку положить в блок на который будет происходить hover. Иначе при выходе мыши за пределы объекта с ховером подсказка продатет. А если она будет внутри объекта с hover, то и сама подсказка тоже будет под действием hover и таким образом не будет скрываться, так как на ней тоже есть hover.
## transition
* не работает с display: none, тк дисплей нон нельзя представить в численном виде. т е можно, но только 1 и 0, без плавных переходов.
## preventDefault
* не ставить preventDefault на все события клавиатуры, т к это может угробит горячие клавиши в браузере.
## margin
* Основные принципы:  
  1. Отступы идут от предыдущего элемента к следующему.
  2. Отступ задается последнему возможному элементу в доме.
  3. Отступы нельзя задавать для независимых элементов ( БЭМ блок ).
  4. У последнего элемента группы, отступ обнуляется (всегда).
## Events 
* событие window.onload и bg картинки. событие следит за картикной если ее задать через js. т е если присвоить img.src в js, то событие onload не сработает пока картинка, которая была задана как img.src, не будет загруена на страницу. 
## Pug
* в самом начале файла pug можно сделать block varibles и запу=ихувать туда все переменные для разных страниц
## gulp
* сделать переменную path для основных папок src и dist
## IE
* img не реагирует на overflow: hidden, height отталкивает все элементы внизу  
## React
* Если вам нужно собрать всю информацию о множественных компонентах, или вам нужно чтобы два дочерних компонента взаимодействовали между собой, то переместите state на верх к родителю, чтобы state находился в родителе этих двух компонентов. Этот родитель может передавать этот state через props своим потомкам, таким образом все компоненты будет синхронизованны между собой и со своим общим родителем. (из документации React)
* Для того чтобы менять state родительского компонента из дочернего, нужно в родительском создать функцию, которую передать в дочерний, и вызвать ее там, чтобы изменить родительский state. Нельзя из дочернего конпонента изменить state родительского, потому что родительский state для дочернего дотупен только для чтения(видимо это связано с безопасностью).
* В react компонентах принято соглашение, что аттрибуты которые обрабатывают события нозывают с префикса on (onClick), а функции обработчики нызвают c префикса handle (handleClick).
* В руковдстве по React сказано, что есть два варинта как можно изменять state у компонента. Первый - это через мутацию, т е явно присваивать старому объекту новые свойства. Втрой - это без мутаций , путем копирования старого объекта и созданием из него нового с ковыми свойствами. Второй вариант рекомнуемый разработчиками, потому что при таком варианте мы можем сохранить все состояния приложения и при необходисомти вернуться к любому старому состоянию.
## HTTPS и SSL
* Итого по каналу SSL:
  1. После того как браузер соединился с каким-то сервером, сервер отправляет серверный публичный ключ в серверном цифровом подписанном сертификате.
  2. Клиент (браузер) генерирует случайное ключевое слово.
  3. Кодирует это ключевое слово при помощи полученного публичного ключа сервера.
  4. Браузер отправляет этот кодированный ключ на сервер.
  5. Сервер при помощи своего секретного ключа расшифровывает это секретное слово.
  6. В итоге у клиента и у сервера появилось общее секретное слово - это симметричный ключ. Необходимость в публичном и закрытом ключе сервера отпадает, потому что теперь вся необходимая инфа кодируется и расшифровывается при помощи симметричного ключа.
## Оптимизация выполнения JavaScript
 * Использовать вместо setTimeout - requestAnimationFrame. Потому что колбек в рекверАнимации срабатывает до прорисовку кадра. А сеттаймаут может сработать после кадра и тем самым может появится эффект подвисания.
 * ВЫносить вычислительную работу в WebWorker, например вычисление результата, сортировка массива, поиск в объекте. Таким образом не занимая основной поток кода. Если все будет выполняться в освновном потоке, то вычисления могут затормозить работу браузера, что приведет к визуальному торможению старницы(код будет выполняться во время того, когда должны были рисоваться карды 60 в секунду).
## Redux (паттерн проектирования)
 * Три основные концепции этого паттерна
  1. Единый источник правды. Только один store, из которого и формируется state для приложения.
  2. Состояние (store) доступно только для чтения. Если кто то хочет отображаться в зависимости от состояния, то он может только его прочитать, изменять он его не может. Состояние может меняться только через Action(это дейстия которые были определены для приложния в момент его инициализации).   
  3. Мутация состояния может осуществляться только чистыми фукнциями(это которые не изменяют store,а создают новый, в концепции redux). эти функции и есть reducer-ы, они определяют как будет создаваться новое состояние store, в зависимости от прешедших данных и типа reducer(type и payload).   
 * Схема работы
  1. Во время инициализации приложения создается store и его reducer(это функции через которые можно изменять этот store). Также для store можно задать начальное состояние.  
  2. Если нужно откуда-то изменить состояние(store), то этот инициатор изменения store должен вызвать функцию store.dispatch - эта функция генерирует для store объект Action, в котором и указана инфа про тип мутации, и полезная нагрузка для store. (Другими словами : Если нужно изменить состояние - диспечеризуется действие (action).   
  3. Action попадает в reducer, который создает __новое__ состояние из старого, мутируя его по данным из Action.    
  4. Ранее подписавшиеся "заинтересованные лица" получают из Store извещение об изменении. (это делается при помощи определенной функции от store. и те кто хочет могут подписаться на изменения в store)
